import { CodeSurfer } from "code-surfer";
import { vsDark } from "@code-surfer/themes";

import Cover from "../components/Cover";
import Back from "../components/Back";
import baseTheme from "../theme";
import "../style.css";

export const theme = {
  ...vsDark,
  ...baseTheme,
};

<Cover
  title="REACT HOOKS"
  speakers={["@dastasoft", "@rubenofen"]}
/>

---

## REACT HOOKS

React Hooks was introduced in React v16.8 and they let you use state<br /> and other React features without writing a class.

- Always use Hooks at the top level of your React function component
- Don't call Hooks inside loops, conditions, or nested functions

---

## USE STATE HOOK

We call it inside a function component to add some local state to it.

**useState** returns a pair

<ul>
  <li>The current state value</li>
  <li>A function that lets you update it</li>
</ul>

---

<CodeSurfer theme={vsDark}>

```js
import React, { useState } from 'react;

// The names of the variables are totally up to you.
const [state, setState] = useState(initialState);
```

```js 4
import React, { useState } from 'react;

// The names of the variables are totally up to you.
const [state, setState] = useState(initialState);
```

</CodeSurfer>

---

## USE EFFECT HOOK

The Effect Hook lets you perform side effects and takes two arguments

<ul>
  <li>A function</li>
  <li>
    An array of inputs which will decide when to execute the
    functions
  </li>
</ul>

---

<CodeSurfer theme={vsDark}>

```js
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

```js 3:5
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

```js 7:11
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

```js 12:15
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

```js 17:19
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

```js 18:26
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

```js
import React, { useEffect } from "react";

useEffect(() => {
  console.log("some stuff when characters creates/updates");
}, [characters]);

useEffect(() => {
  console.log(
    "some stuff when characters or jobs creates/updates"
  );
}, [characters, jobs]);

useEffect(() => {
  console.log("some stuff when component gets mounted");
}, []);

useEffect(() => {
  console.log("some stuff running every render cycle");
});

useEffect(() => {
  console.log("some stuff when component did mount");
  return () => {
    console.log("some stuff when component did unmount");
  };
}, []);
```

</CodeSurfer>

---

## USE CONTEXT HOOK

The Context API allows us to share data considered "global" for<br/> a tree of React components.

Using context, we can avoid passing props through intermediate<br /> components.

**We can have multiple contexts in our app**

---

<CodeSurfer theme={vsDark}>

```js
import React, { useContext } from "react";
import authContext from "../contexts/AuthContext";

const auth = useContext(authContext);
```

</CodeSurfer>

---

## USE REF HOOK

Refs provide a way to access DOM nodes or React elements created<br /> in the render method.

<ul>
  <li>useRef return a mutable ref object</li>
  <li>
    The returned object will persis for the full lifetime of
    the component
  </li>
</ul>

---

<CodeSurfer theme={vsDark}>

```js
import React, { useRef } from "react";

const FocusInput = () => {
  const inputEl = useRef();

  const focusInput = () => {
    inputEl.current.focus();
  };

  return (
    <>
      <input ref={inputEl} type="text" />
      <button onClick={focusInput}>Focus input</button>
    </>
  );
};
```

</CodeSurfer>

---

## USE REDUCER HOOK

A reducer is a function that helps to manage a state.

It takes the current state and the action, based on the action<br /> the reducer performs a certain state transition.

---

<CodeSurfer theme={vsDark}>

```js
const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(
    reducer,
    initialState
  );
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({ type: "decrement" })}
      >
        -
      </button>
      <button
        onClick={() => dispatch({ type: "increment" })}
      >
        +
      </button>
    </>
  );
};
```

```js 4:8
const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(
    reducer,
    initialState
  );
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({ type: "decrement" })}
      >
        -
      </button>
      <button
        onClick={() => dispatch({ type: "increment" })}
      >
        +
      </button>
    </>
  );
};
```

```js
const initialState = { count: 0 };

const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(
    reducer,
    initialState
  );
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({ type: "decrement" })}
      >
        -
      </button>
      <button
        onClick={() => dispatch({ type: "increment" })}
      >
        +
      </button>
    </>
  );
};
```

</CodeSurfer>

---

# USE REDUCER HOOK

The **useReducer** hook is recommended over **useState** when

- You have complex state logic that involves multiple sub-values
- The next state depends on the previous one

---

## CUSTOM HOOKS

Custom Hooks are a great way to share logic between components.

We only need to declare a function, and return a object or an array.

---

## CUSTOM HOOK

<ul>
  <li>
    We will use the pattern for the name "useXxxYyy" for
    linter propouses
  </li>
  <li>
    You can call other hooks inside of your custom hook
  </li>
  <li>
    Custom Hooks are a mechanism to reuse stateful logic
  </li>
</ul>

The state inside of a custom hook is isolated, that means<br />
if you use the same hook in two different components, the<br/>
state inside of the hook isn't shared.

---

<CodeSurfer theme={vsDark}>

```js
import { useState, useEffect } from 'react;

const useAuthHandler = (initialState) => {
    const [auth, setAuth] = useState(initialStatus);

    const setAuthStatus = userAuth => {
        window.localStorage.setItem("UserAuth", JSON.stringify(userAuth));
        settAuth(userAuth)
    };

    const setUnauthStatus = () => {
        window.localStorage.clear();
        setAuth('');
    }

    return {
        auth,
        setAuthStatus,
        setUnauthStatus
    }
}

import { useAuthHandler } from '../hooks/AuthHandler';

const { auth, setAuthStatus, setUnauthStatus } = useAuthHandler(initialValue);
```

</CodeSurfer>

---

<Back title="REACT HOOKS" />
